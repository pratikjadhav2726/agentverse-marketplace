# Agent2Agent (A2A) Protocol Integration Guide

## Overview

This document provides comprehensive guidance for integrating the Agent2Agent (A2A) protocol into the Enterprise AI Agent Marketplace. The A2A protocol enables secure, scalable, and seamless collaboration between autonomous AI agents, serving as the foundational communication layer for our multi-agent ecosystem.

## A2A Protocol Fundamentals

### Core Concepts

The A2A protocol is built on several key architectural components:

1. **Agent Card**: A standardized JSON metadata file that serves as a digital business card
2. **Task**: A discrete unit of work with a defined lifecycle
3. **Message**: The fundamental unit of communication between agents
4. **Artifact**: Tangible products or results generated by agents
5. **Part**: Granular pieces of content within messages and artifacts

### Communication Patterns

A2A supports three primary communication patterns:

1. **Request/Response (Polling)**: Traditional synchronous communication
2. **Streaming (Server-Sent Events)**: Real-time updates for long-running tasks
3. **Push Notifications (Webhooks)**: Asynchronous notifications for very long-running tasks

## Implementation Architecture

### High-Level Integration Flow

```
┌─────────────────┐    A2A Protocol    ┌─────────────────┐
│   Client Agent  │◄──────────────────►│  Remote Agent   │
│                 │                    │                 │
│ • Task Creation │                    │ • Task Processing│
│ • Progress Mon. │                    │ • Status Updates │
│ • Result Retrieval                   │ • Artifact Gen.  │
└─────────────────┘                    └─────────────────┘
         │                                      │
         ▼                                      ▼
┌─────────────────────────────────────────────────────────┐
│              A2A Gateway/Orchestrator                   │
├─────────────────────────────────────────────────────────┤
│ • Agent Discovery & Registration                       │
│ • Protocol Translation & Routing                       │
│ • Task Lifecycle Management                            │
│ • Security & Authentication                            │
│ • Load Balancing & Scaling                             │
└─────────────────────────────────────────────────────────┘
```

## Core Components Implementation

### 1. Agent Card Implementation

#### Agent Card Schema
```typescript
interface AgentCard {
  // Identity
  name: string;
  description: string;
  version: string;
  
  // Service Information
  serviceEndpoint: string;
  
  // Capabilities
  capabilities: AgentCapability[];
  supportedModalities: Modality[];
  
  // A2A Features
  a2aCapabilities: A2ACapability[];
  
  // Authentication
  authenticationRequired: AuthMethod[];
  
  // Metadata
  metadata: Record<string, any>;
}

interface AgentCapability {
  name: string;
  description: string;
  inputSchema?: JSONSchema;
  outputSchema?: JSONSchema;
  examples?: Example[];
}

interface A2ACapability {
  streaming: boolean;
  pushNotifications: boolean;
  batchProcessing: boolean;
  multiModal: boolean;
}
```

#### Agent Card Validation Service
```typescript
class AgentCardValidator {
  private static schema = {
    type: "object",
    required: ["name", "description", "version", "serviceEndpoint", "capabilities"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 100 },
      description: { type: "string", minLength: 10, maxLength: 500 },
      version: { type: "string", pattern: "^\\d+\\.\\d+\\.\\d+$" },
      serviceEndpoint: { type: "string", format: "uri" },
      capabilities: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["name", "description"],
          properties: {
            name: { type: "string" },
            description: { type: "string" }
          }
        }
      }
    }
  };

  static validate(agentCard: AgentCard): ValidationResult {
    const ajv = new Ajv();
    const validate = ajv.compile(this.schema);
    const valid = validate(agentCard);
    
    return {
      valid,
      errors: validate.errors || []
    };
  }

  static async validateEndpoint(endpoint: string): Promise<boolean> {
    try {
      const response = await fetch(`${endpoint}/health`);
      return response.ok;
    } catch {
      return false;
    }
  }
}
```

### 2. A2A Protocol Handler

#### Core Protocol Implementation
```typescript
class A2AProtocolHandler {
  private rpcServer: JSONRPCServer;
  private sseManager: SSEManager;
  private webhookManager: WebhookManager;
  
  constructor(
    private agentRegistry: AgentRegistry,
    private taskManager: TaskManager,
    private authService: AuthenticationService
  ) {
    this.setupRPCServer();
    this.setupSSEManager();
    this.setupWebhookManager();
  }

  // HTTP/JSON-RPC Implementation
  private setupRPCServer(): void {
    this.rpcServer = new JSONRPCServer();
    
    // Agent Discovery
    this.rpcServer.addMethod("agent.discover", async (params: AgentDiscoveryParams) => {
      return await this.discoverAgents(params);
    });
    
    // Task Management
    this.rpcServer.addMethod("task.create", async (params: TaskCreationParams) => {
      return await this.createTask(params);
    });
    
    this.rpcServer.addMethod("task.get", async (params: { taskId: string }) => {
      return await this.getTaskStatus(params.taskId);
    });
    
    this.rpcServer.addMethod("task.cancel", async (params: { taskId: string }) => {
      return await this.cancelTask(params.taskId);
    });
  }

  // Agent Discovery Implementation
  async discoverAgents(params: AgentDiscoveryParams): Promise<Agent[]> {
    const { capabilities, modalities, filters } = params;
    
    let query = this.agentRegistry.createQuery();
    
    if (capabilities?.length) {
      query = query.withCapabilities(capabilities);
    }
    
    if (modalities?.length) {
      query = query.withModalities(modalities);
    }
    
    if (filters) {
      query = query.withFilters(filters);
    }
    
    const agents = await query.execute();
    
    // Filter by availability and performance metrics
    return agents.filter(agent => 
      agent.status === 'active' && 
      agent.performanceScore > 0.8
    );
  }

  // Task Creation and Management
  async createTask(params: TaskCreationParams): Promise<Task> {
    const { agentId, input, priority = 'normal', timeout } = params;
    
    // Validate agent exists and is available
    const agent = await this.agentRegistry.getAgent(agentId);
    if (!agent || agent.status !== 'active') {
      throw new A2AError('AGENT_UNAVAILABLE', 'Agent is not available');
    }
    
    // Create task
    const task = await this.taskManager.createTask({
      id: generateUUID(),
      agentId,
      status: 'submitted',
      input,
      priority,
      timeout,
      createdAt: new Date(),
      updatedAt: new Date()
    });
    
    // Delegate to agent
    await this.delegateTask(task, agent);
    
    return task;
  }

  private async delegateTask(task: Task, agent: Agent): Promise<void> {
    const delegationMessage: A2AMessage = {
      id: generateUUID(),
      type: 'task_delegation',
      taskId: task.id,
      payload: {
        task: task.input,
        context: task.context,
        requirements: task.requirements
      },
      timestamp: new Date().toISOString()
    };
    
    try {
      // Send task to agent endpoint
      const response = await this.sendToAgent(agent.serviceEndpoint, delegationMessage);
      
      // Update task status
      await this.taskManager.updateTaskStatus(task.id, 'working');
      
      // Start monitoring if agent supports streaming
      if (agent.a2aCapabilities.streaming) {
        this.monitorTaskProgress(task.id, agent);
      }
      
    } catch (error) {
      await this.taskManager.updateTaskStatus(task.id, 'failed');
      throw error;
    }
  }
}
```

### 3. Server-Sent Events (SSE) Implementation

```typescript
class SSEManager {
  private connections: Map<string, SSEConnection> = new Map();
  
  async createStream(taskId: string, clientId: string): Promise<void> {
    const connection = new SSEConnection(taskId, clientId);
    this.connections.set(`${taskId}:${clientId}`, connection);
    
    // Send initial connection event
    connection.send({
      type: 'connection_established',
      data: { taskId, timestamp: new Date().toISOString() }
    });
  }
  
  async sendUpdate(taskId: string, update: TaskUpdate): Promise<void> {
    const connections = Array.from(this.connections.entries())
      .filter(([key]) => key.startsWith(`${taskId}:`))
      .map(([, connection]) => connection);
    
    for (const connection of connections) {
      connection.send({
        type: 'task_update',
        data: update
      });
    }
  }
  
  closeStream(taskId: string, clientId: string): void {
    const key = `${taskId}:${clientId}`;
    const connection = this.connections.get(key);
    if (connection) {
      connection.close();
      this.connections.delete(key);
    }
  }
}

class SSEConnection {
  private response: Response;
  private encoder = new TextEncoder();
  
  constructor(
    private taskId: string,
    private clientId: string
  ) {}
  
  send(event: SSEEvent): void {
    const data = `data: ${JSON.stringify(event)}\n\n`;
    this.response.write(this.encoder.encode(data));
  }
  
  close(): void {
    this.response.end();
  }
}
```

### 4. Webhook Management

```typescript
class WebhookManager {
  private webhooks: Map<string, WebhookRegistration> = new Map();
  
  async registerWebhook(registration: WebhookRegistration): Promise<void> {
    // Validate webhook URL
    await this.validateWebhookURL(registration.url);
    
    // Store registration
    this.webhooks.set(registration.id, registration);
    
    // Set up cleanup timer
    if (registration.expiresAt) {
      setTimeout(() => {
        this.webhooks.delete(registration.id);
      }, registration.expiresAt.getTime() - Date.now());
    }
  }
  
  async notifyWebhook(taskId: string, event: WebhookEvent): Promise<void> {
    const registrations = Array.from(this.webhooks.values())
      .filter(reg => reg.taskId === taskId && reg.events.includes(event.type));
    
    for (const registration of registrations) {
      try {
        await this.sendWebhookNotification(registration, event);
      } catch (error) {
        console.error(`Webhook notification failed: ${registration.url}`, error);
        // Implement retry logic here
      }
    }
  }
  
  private async sendWebhookNotification(
    registration: WebhookRegistration, 
    event: WebhookEvent
  ): Promise<void> {
    const payload = {
      id: generateUUID(),
      timestamp: new Date().toISOString(),
      event: event.type,
      data: event.data
    };
    
    const signature = this.generateSignature(payload, registration.secret);
    
    await fetch(registration.url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-A2A-Signature': signature,
        'X-A2A-Event': event.type
      },
      body: JSON.stringify(payload)
    });
  }
  
  private generateSignature(payload: any, secret: string): string {
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(JSON.stringify(payload));
    return `sha256=${hmac.digest('hex')}`;
  }
}
```

## Security Implementation

### Authentication & Authorization

```typescript
class A2ASecurityManager {
  async authenticateAgent(agentId: string, credentials: AgentCredentials): Promise<AuthResult> {
    // Verify agent certificate
    if (credentials.certificate) {
      const isValid = await this.verifyCertificate(credentials.certificate);
      if (!isValid) {
        throw new A2AError('INVALID_CERTIFICATE', 'Agent certificate is invalid');
      }
    }
    
    // Verify JWT token if provided
    if (credentials.jwt) {
      const tokenPayload = await this.verifyJWT(credentials.jwt);
      if (tokenPayload.sub !== agentId) {
        throw new A2AError('INVALID_TOKEN', 'JWT token subject does not match agent ID');
      }
    }
    
    // Generate session token
    const sessionToken = await this.generateSessionToken(agentId);
    
    return {
      success: true,
      sessionToken,
      expiresAt: new Date(Date.now() + 3600000) // 1 hour
    };
  }
  
  async authorizeAction(agentId: string, action: string, resource: string): Promise<boolean> {
    const agent = await this.agentRegistry.getAgent(agentId);
    if (!agent) return false;
    
    const permissions = await this.getAgentPermissions(agentId);
    return permissions.some(permission => 
      permission.action === action && 
      permission.resource === resource
    );
  }
  
  private async verifyJWT(token: string): Promise<JWTPayload> {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!);
      return decoded as JWTPayload;
    } catch (error) {
      throw new A2AError('INVALID_JWT', 'JWT verification failed');
    }
  }
}
```

### Message Encryption

```typescript
class MessageEncryption {
  async encryptMessage(message: A2AMessage, recipientPublicKey: string): Promise<EncryptedMessage> {
    // Generate ephemeral key pair
    const ephemeralKeyPair = crypto.generateKeyPairSync('ec', {
      namedCurve: 'secp256k1'
    });
    
    // Derive shared secret
    const sharedSecret = crypto.diffieHellman({
      privateKey: ephemeralKeyPair.privateKey,
      publicKey: crypto.createPublicKey(recipientPublicKey)
    });
    
    // Encrypt message
    const cipher = crypto.createCipher('aes-256-gcm', sharedSecret);
    const encrypted = cipher.update(JSON.stringify(message), 'utf8', 'hex') + cipher.final('hex');
    const authTag = cipher.getAuthTag();
    
    return {
      ephemeralPublicKey: ephemeralKeyPair.publicKey.export({ type: 'spki', format: 'pem' }),
      encryptedData: encrypted,
      authTag: authTag.toString('hex'),
      algorithm: 'ECDH-ES+A256GCM'
    };
  }
  
  async decryptMessage(encryptedMessage: EncryptedMessage, privateKey: string): Promise<A2AMessage> {
    // Derive shared secret
    const sharedSecret = crypto.diffieHellman({
      privateKey: crypto.createPrivateKey(privateKey),
      publicKey: crypto.createPublicKey(encryptedMessage.ephemeralPublicKey)
    });
    
    // Decrypt message
    const decipher = crypto.createDecipher('aes-256-gcm', sharedSecret);
    decipher.setAuthTag(Buffer.from(encryptedMessage.authTag, 'hex'));
    
    const decrypted = decipher.update(encryptedMessage.encryptedData, 'hex', 'utf8') + decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}
```

## Agent Registry Implementation

### Dynamic Agent Discovery

```typescript
class AgentDiscoveryService {
  private capabilityIndex: Map<string, Set<string>> = new Map();
  private modalityIndex: Map<string, Set<string>> = new Map();
  private performanceMetrics: Map<string, AgentMetrics> = new Map();
  
  async indexAgent(agent: Agent): Promise<void> {
    // Index by capabilities
    for (const capability of agent.capabilities) {
      if (!this.capabilityIndex.has(capability.name)) {
        this.capabilityIndex.set(capability.name, new Set());
      }
      this.capabilityIndex.get(capability.name)!.add(agent.id);
    }
    
    // Index by modalities
    for (const modality of agent.supportedModalities) {
      if (!this.modalityIndex.has(modality)) {
        this.modalityIndex.set(modality, new Set());
      }
      this.modalityIndex.get(modality)!.add(agent.id);
    }
    
    // Initialize performance metrics
    this.performanceMetrics.set(agent.id, {
      successRate: 1.0,
      averageResponseTime: 0,
      throughput: 0,
      lastUpdated: new Date()
    });
  }
  
  async discoverAgents(criteria: DiscoveryCriteria): Promise<Agent[]> {
    let candidateIds: Set<string> = new Set();
    
    // Filter by capabilities
    if (criteria.capabilities?.length) {
      const capabilitySets = criteria.capabilities.map(cap => 
        this.capabilityIndex.get(cap) || new Set()
      );
      candidateIds = this.intersectSets(capabilitySets);
    }
    
    // Filter by modalities
    if (criteria.modalities?.length) {
      const modalitySets = criteria.modalities.map(mod => 
        this.modalityIndex.get(mod) || new Set()
      );
      const modalityIds = this.intersectSets(modalitySets);
      
      if (candidateIds.size > 0) {
        candidateIds = this.intersectSets([candidateIds, modalityIds]);
      } else {
        candidateIds = modalityIds;
      }
    }
    
    // Get full agent objects
    const agents = await Promise.all(
      Array.from(candidateIds).map(id => this.agentRegistry.getAgent(id))
    );
    
    // Filter by performance criteria
    return this.rankAgentsByPerformance(
      agents.filter(agent => agent && agent.status === 'active'),
      criteria.performanceThreshold
    );
  }
  
  private intersectSets(sets: Set<string>[]): Set<string> {
    if (sets.length === 0) return new Set();
    
    return sets.reduce((intersection, currentSet) => {
      return new Set([...intersection].filter(x => currentSet.has(x)));
    });
  }
  
  private rankAgentsByPerformance(agents: Agent[], threshold?: number): Agent[] {
    const rankedAgents = agents
      .map(agent => ({
        agent,
        metrics: this.performanceMetrics.get(agent.id)!
      }))
      .filter(({ metrics }) => !threshold || metrics.successRate >= threshold)
      .sort((a, b) => {
        // Sort by success rate (desc) then by response time (asc)
        if (a.metrics.successRate !== b.metrics.successRate) {
          return b.metrics.successRate - a.metrics.successRate;
        }
        return a.metrics.averageResponseTime - b.metrics.averageResponseTime;
      })
      .map(({ agent }) => agent);
    
    return rankedAgents;
  }
}
```

## Task Lifecycle Management

### Task State Machine

```typescript
enum TaskStatus {
  SUBMITTED = 'submitted',
  WORKING = 'working',
  INPUT_REQUIRED = 'input-required',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

class TaskStateMachine {
  private static readonly transitions: Map<TaskStatus, TaskStatus[]> = new Map([
    [TaskStatus.SUBMITTED, [TaskStatus.WORKING, TaskStatus.FAILED, TaskStatus.CANCELLED]],
    [TaskStatus.WORKING, [TaskStatus.INPUT_REQUIRED, TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]],
    [TaskStatus.INPUT_REQUIRED, [TaskStatus.WORKING, TaskStatus.FAILED, TaskStatus.CANCELLED]],
    [TaskStatus.COMPLETED, []],
    [TaskStatus.FAILED, []],
    [TaskStatus.CANCELLED, []]
  ]);
  
  static canTransition(from: TaskStatus, to: TaskStatus): boolean {
    const allowedTransitions = this.transitions.get(from) || [];
    return allowedTransitions.includes(to);
  }
  
  static validateTransition(from: TaskStatus, to: TaskStatus): void {
    if (!this.canTransition(from, to)) {
      throw new A2AError(
        'INVALID_TRANSITION',
        `Cannot transition from ${from} to ${to}`
      );
    }
  }
}

class TaskManager {
  async updateTaskStatus(
    taskId: string, 
    newStatus: TaskStatus, 
    metadata?: Record<string, any>
  ): Promise<Task> {
    const task = await this.getTask(taskId);
    if (!task) {
      throw new A2AError('TASK_NOT_FOUND', `Task ${taskId} not found`);
    }
    
    // Validate state transition
    TaskStateMachine.validateTransition(task.status as TaskStatus, newStatus);
    
    // Update task
    const updatedTask = await this.repository.update(taskId, {
      status: newStatus,
      metadata: { ...task.metadata, ...metadata },
      updatedAt: new Date()
    });
    
    // Emit status change event
    await this.eventEmitter.emit('task.status.changed', {
      taskId,
      previousStatus: task.status,
      newStatus,
      timestamp: new Date()
    });
    
    return updatedTask;
  }
}
```

## Performance Optimization

### Caching Strategy

```typescript
class A2ACacheManager {
  private agentCardCache: Map<string, { card: AgentCard; expiry: number }> = new Map();
  private taskResultCache: Map<string, { result: any; expiry: number }> = new Map();
  
  async getAgentCard(agentId: string): Promise<AgentCard | null> {
    const cached = this.agentCardCache.get(agentId);
    if (cached && cached.expiry > Date.now()) {
      return cached.card;
    }
    
    // Fetch from registry
    const card = await this.agentRegistry.getAgentCard(agentId);
    if (card) {
      this.agentCardCache.set(agentId, {
        card,
        expiry: Date.now() + 300000 // 5 minutes
      });
    }
    
    return card;
  }
  
  async cacheTaskResult(taskId: string, result: any, ttl: number = 3600000): Promise<void> {
    this.taskResultCache.set(taskId, {
      result,
      expiry: Date.now() + ttl
    });
  }
  
  async getTaskResult(taskId: string): Promise<any | null> {
    const cached = this.taskResultCache.get(taskId);
    if (cached && cached.expiry > Date.now()) {
      return cached.result;
    }
    return null;
  }
}
```

### Connection Pooling

```typescript
class A2AConnectionPool {
  private pools: Map<string, Pool> = new Map();
  
  async getConnection(agentEndpoint: string): Promise<Connection> {
    if (!this.pools.has(agentEndpoint)) {
      this.pools.set(agentEndpoint, new Pool({
        factory: () => this.createConnection(agentEndpoint),
        max: 10,
        min: 2,
        acquireTimeoutMillis: 5000,
        idleTimeoutMillis: 30000
      }));
    }
    
    const pool = this.pools.get(agentEndpoint)!;
    return await pool.acquire();
  }
  
  async releaseConnection(agentEndpoint: string, connection: Connection): Promise<void> {
    const pool = this.pools.get(agentEndpoint);
    if (pool) {
      await pool.release(connection);
    }
  }
  
  private async createConnection(endpoint: string): Promise<Connection> {
    return new HTTPConnection(endpoint, {
      timeout: 30000,
      retries: 3,
      keepAlive: true
    });
  }
}
```

## Error Handling & Resilience

### Circuit Breaker Pattern

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  constructor(
    private threshold: number = 5,
    private timeout: number = 60000,
    private resetTimeout: number = 30000
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new A2AError('CIRCUIT_BREAKER_OPEN', 'Circuit breaker is open');
      }
    }
    
    try {
      const result = await Promise.race([
        operation(),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), this.timeout)
        )
      ]);
      
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failures = 0;
    this.state = 'CLOSED';
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}
```

## Testing Strategy

### Integration Tests

```typescript
describe('A2A Protocol Integration', () => {
  let protocolHandler: A2AProtocolHandler;
  let mockAgent: MockAgent;
  
  beforeEach(async () => {
    protocolHandler = new A2AProtocolHandler(/* dependencies */);
    mockAgent = new MockAgent('test-agent');
    await mockAgent.start();
  });
  
  afterEach(async () => {
    await mockAgent.stop();
  });
  
  describe('Agent Discovery', () => {
    it('should discover agents by capability', async () => {
      // Register mock agent
      await protocolHandler.registerAgent(mockAgent.getAgentCard());
      
      // Discover agents
      const agents = await protocolHandler.discoverAgents({
        capabilities: ['text-analysis']
      });
      
      expect(agents).toHaveLength(1);
      expect(agents[0].id).toBe(mockAgent.id);
    });
  });
  
  describe('Task Delegation', () => {
    it('should create and delegate task successfully', async () => {
      const task = await protocolHandler.createTask({
        agentId: mockAgent.id,
        input: { text: 'Hello, world!' },
        priority: 'high'
      });
      
      expect(task.status).toBe('submitted');
      
      // Wait for task completion
      await waitForCondition(() => task.status === 'completed', 5000);
      
      expect(task.output).toBeDefined();
    });
    
    it('should handle task failures gracefully', async () => {
      mockAgent.setShouldFail(true);
      
      const task = await protocolHandler.createTask({
        agentId: mockAgent.id,
        input: { text: 'This will fail' }
      });
      
      await waitForCondition(() => task.status === 'failed', 5000);
      
      expect(task.status).toBe('failed');
      expect(task.error).toBeDefined();
    });
  });
  
  describe('Streaming Updates', () => {
    it('should receive real-time task updates', async () => {
      const updates: TaskUpdate[] = [];
      
      const stream = protocolHandler.streamTaskUpdates('test-task-id');
      
      for await (const update of stream) {
        updates.push(update);
        if (update.status === 'completed') break;
      }
      
      expect(updates.length).toBeGreaterThan(1);
      expect(updates[updates.length - 1].status).toBe('completed');
    });
  });
});
```

## Deployment Configuration

### Docker Configuration

```dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY dist ./dist

# Expose A2A protocol port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["node", "dist/server.js"]
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: a2a-gateway
  labels:
    app: a2a-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: a2a-gateway
  template:
    metadata:
      labels:
        app: a2a-gateway
    spec:
      containers:
      - name: a2a-gateway
        image: marketplace/a2a-gateway:latest
        ports:
        - containerPort: 8080
        env:
        - name: NODE_ENV
          value: "production"
        - name: A2A_PORT
          value: "8080"
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: a2a-gateway-service
spec:
  selector:
    app: a2a-gateway
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

## Monitoring & Observability

### Metrics Collection

```typescript
class A2AMetrics {
  private static registry = new prometheus.Registry();
  
  // Counters
  private static taskCreatedCounter = new prometheus.Counter({
    name: 'a2a_tasks_created_total',
    help: 'Total number of tasks created',
    labelNames: ['agent_id', 'priority']
  });
  
  private static taskCompletedCounter = new prometheus.Counter({
    name: 'a2a_tasks_completed_total',
    help: 'Total number of tasks completed',
    labelNames: ['agent_id', 'status']
  });
  
  // Histograms
  private static taskDurationHistogram = new prometheus.Histogram({
    name: 'a2a_task_duration_seconds',
    help: 'Task execution duration in seconds',
    labelNames: ['agent_id'],
    buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60, 300]
  });
  
  // Gauges
  private static activeTasks = new prometheus.Gauge({
    name: 'a2a_active_tasks',
    help: 'Number of currently active tasks',
    labelNames: ['agent_id']
  });
  
  static recordTaskCreated(agentId: string, priority: string): void {
    this.taskCreatedCounter.inc({ agent_id: agentId, priority });
    this.activeTasks.inc({ agent_id: agentId });
  }
  
  static recordTaskCompleted(agentId: string, status: string, duration: number): void {
    this.taskCompletedCounter.inc({ agent_id: agentId, status });
    this.taskDurationHistogram.observe({ agent_id: agentId }, duration);
    this.activeTasks.dec({ agent_id: agentId });
  }
  
  static getMetrics(): string {
    return this.registry.metrics();
  }
}
```

## Best Practices & Recommendations

### 1. Agent Development Guidelines

- **Stateless Design**: Agents should be stateless to support horizontal scaling
- **Idempotency**: Operations should be idempotent to handle retries safely
- **Graceful Degradation**: Agents should handle partial failures gracefully
- **Resource Management**: Implement proper resource cleanup and limits

### 2. Security Best Practices

- **Authentication**: Always verify agent identity before processing requests
- **Authorization**: Implement fine-grained access controls
- **Encryption**: Encrypt sensitive data in transit and at rest
- **Audit Logging**: Log all security-relevant events

### 3. Performance Optimization

- **Connection Pooling**: Reuse connections to reduce overhead
- **Caching**: Cache frequently accessed data and results
- **Batching**: Batch multiple operations when possible
- **Async Processing**: Use asynchronous patterns for I/O operations

### 4. Error Handling

- **Circuit Breakers**: Implement circuit breakers for external dependencies
- **Retries**: Use exponential backoff for transient failures
- **Timeouts**: Set appropriate timeouts for all operations
- **Monitoring**: Monitor error rates and patterns

---

**Document Version**: 1.0  
**Last Updated**: [Current Date]  
**Next Review**: Monthly  
**Stakeholders**: Engineering Team, Architecture Team, DevOps Team